{"version":3,"sources":["candy-machine.ts","connection.tsx","MintButton.tsx","Home.tsx","App.tsx","reportWebVitals.ts","index.tsx","utils.ts"],"names":["CANDY_MACHINE_PROGRAM","anchor","PublicKey","TOKEN_METADATA_PROGRAM_ID","awaitTransactionSignatureConfirmation","txid","timeout","connection","a","queryStatus","done","status","slot","confirmations","err","subId","Promise","resolve","reject","setTimeout","console","log","getSignatureStatuses","signatureStatuses","value","sleep","_signatureSubscriptions","removeSignatureListener","createAssociatedTokenAccountInstruction","associatedTokenAddress","payer","walletAddress","splTokenMintAddress","keys","pubkey","isSigner","isWritable","SystemProgram","programId","TOKEN_PROGRAM_ID","SYSVAR_RENT_PUBKEY","TransactionInstruction","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","data","Buffer","from","getCandyMachineState","anchorWallet","candyMachineId","provider","preflightCommitment","fetchIdl","idl","program","account","candyMachine","fetch","state","itemsAvailable","toNumber","itemsRedeemed","itemsRemaining","id","isSoldOut","isActive","goLiveDate","Date","getTime","endSettings","endSettingType","date","number","treasury","wallet","tokenMint","gatekeeper","whitelistMintSettings","hiddenSettings","price","getMasterEdition","mint","findProgramAddress","toBuffer","getMetadata","getCandyMachineCreator","mintOneToken","getAtaForMint","publicKey","userTokenAccountAddress","userPayingAccountAddress","candyMachineAddress","remainingAccounts","signers","cleanupInstructions","MintLayout","span","getMinimumBalanceForRentExemption","fromPubkey","newAccountPubkey","space","lamports","createAccount","Token","createInitMintInstruction","createMintToInstruction","instructions","getNetworkToken","gatekeeperNetwork","push","expireOnUse","CIVIC","getNetworkExpire","whitelistToken","mode","burnEveryTime","whitelistBurnAuthority","Keypair","generate","getAccountInfo","createApproveInstruction","createRevokeInstruction","transferAuthority","metadataAddress","masterEdition","candyMachineCreator","creatorBump","instruction","mintNft","accounts","metadata","mintAuthority","updateAuthority","tokenMetadataProgram","tokenProgram","systemProgram","rent","clock","SYSVAR_CLOCK_PUBKEY","recentBlockhashes","SYSVAR_RECENT_BLOCKHASHES_PUBKEY","instructionSysvarAccount","SYSVAR_INSTRUCTIONS_PUBKEY","length","undefined","sendTransactions","txs","map","t","ms","SequenceType","instructionSet","signersSet","sequenceType","Parallel","commitment","successCallback","ind","failCallback","block","WalletNotConnectedError","unsignedTxns","getRecentBlockhash","i","transaction","Transaction","forEach","add","recentBlockhash","blockhash","setSigners","s","partialSign","signAllTransactions","signedTxns","pendingTxns","breakEarlyObject","breakEarly","signedTxnPromise","sendSignedTransaction","signedTransaction","then","catch","reason","StopOnFailure","all","getUnixTs","DEFAULT_TIMEOUT","rawTransaction","serialize","startTime","sendRawTransaction","skipPreflight","confirmation","Error","error","simulateResult","simulateTransaction","logs","line","startsWith","slice","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","args","encoding","_rpcRequest","res","message","result","onSignature","context","e","CTAButton","styled","Button","MintButton","onMint","isMinting","isEnded","useGateway","requestGatewayToken","gatewayStatus","useState","clicked","setClicked","isVerifying","setIsVerifying","useEffect","GatewayStatus","COLLECTING_USER_INFORMATION","ACTIVE","disabled","onClick","variant","CircularProgress","cluster","process","decimals","splTokenName","WalletContainer","div","WalletAmount","Wallet","ul","ConnectButton","WalletMultiButton","NFT","Paper","Des","Card","MintButtonContainer","Logo","Menu","SolExplorerLink","MainContainer","MintContainer","DesContainer","Price","Chip","Image","img","BorderLinearProgress","LinearProgress","ShimmerTitle","h1","GoldTitle","h2","LogoAligner","Home","props","balance","setBalance","setIsMinting","setIsActive","solanaExplorerLink","setSolanaExplorerLink","setItemsAvailable","setItemsRedeemed","setItemsRemaining","setIsSoldOut","payWithSplToken","setPayWithSplToken","setPrice","priceLabel","setPriceLabel","whitelistPrice","setWhitelistPrice","whitelistEnabled","setWhitelistEnabled","isBurnToken","setIsBurnToken","whitelistTokenBalance","setWhitelistTokenBalance","setIsEnded","endDate","setEndDate","isPresale","setIsPresale","isWLOnly","setIsWLOnly","open","severity","alertState","setAlertState","useAnchorWallet","setCandyMachine","rpcUrl","rpcHost","displaySuccess","mintPublicKey","remaining","confetti","particleCount","spread","origin","y","mintTxId","txTimeout","msg","code","indexOf","getBalance","LAMPORTS_PER_SOL","cndy","divider","Array","join","presale","discountPrice","getTokenAccountBalance","tokenBalance","uiAmount","toDate","amount","limit","Math","min","href","target","rel","alt","src","toLocaleString","elevation","label","now","onMount","completed","onComplete","renderer","days","hours","minutes","signTransaction","clusterUrl","options","autoShowModal","seconds","Snackbar","autoHideDuration","onClose","Alert","require","network","Connection","theme","createTheme","palette","type","overrides","MuiButtonBase","root","justifyContent","MuiButton","textTransform","padding","startIcon","marginRight","endIcon","marginLeft","App","endpoint","useMemo","clusterApiUrl","wallets","getPhantomWallet","getSlopeWallet","getSolflareWallet","getSolflareWebWallet","getSolletWallet","getSolletExtensionWallet","getSolongWallet","getLedgerWallet","getSafePalWallet","ThemeProvider","ConnectionProvider","WalletProvider","autoConnect","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","Intl","NumberFormat","style","minimumFractionDigits","maximumFractionDigits","buyer"],"mappings":"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","file":"static/js/main.7fd48a4f.chunk.js","sourcesContent":["import * as anchor from \"@project-serum/anchor\";\n\nimport {\n  MintLayout,\n  TOKEN_PROGRAM_ID,\n  Token,\n} from \"@solana/spl-token\";\n\nimport { SystemProgram } from '@solana/web3.js';\nimport { sendTransactions } from './connection';\n\nimport {\n  CIVIC,\n  getAtaForMint,\n  getNetworkExpire,\n  getNetworkToken,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n} from './utils';\n\nexport const CANDY_MACHINE_PROGRAM = new anchor.web3.PublicKey(\n  \"cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ\"\n);\n\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\n  \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\n);\n\nexport interface CandyMachine {\n  id: anchor.web3.PublicKey,\n  program: anchor.Program;\n  state: CandyMachineState;\n}\n\ninterface CandyMachineState {\n  itemsAvailable: number;\n  itemsRedeemed: number;\n  itemsRemaining: number;\n  treasury: anchor.web3.PublicKey;\n  tokenMint: anchor.web3.PublicKey;\n  isSoldOut: boolean;\n  isActive: boolean;\n  goLiveDate: anchor.BN;\n  price: anchor.BN;\n  gatekeeper: null | {\n    expireOnUse: boolean;\n    gatekeeperNetwork: anchor.web3.PublicKey;\n  };\n  endSettings: null | {\n    number: anchor.BN;\n    endSettingType: any;\n  };\n  whitelistMintSettings: null | {\n    mode: any;\n    mint: anchor.web3.PublicKey;\n    presale: boolean;\n    discountPrice: null | anchor.BN;\n  };\n  hiddenSettings: null | {\n    name: string;\n    uri: string;\n    hash: Uint8Array;\n  };\n}\n\nexport const awaitTransactionSignatureConfirmation = async (\n  txid: anchor.web3.TransactionSignature,\n  timeout: number,\n  connection: anchor.web3.Connection,\n  commitment: anchor.web3.Commitment = 'recent',\n  queryStatus = false,\n): Promise<anchor.web3.SignatureStatus | null | void> => {\n  let done = false;\n  let status: anchor.web3.SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId]) {\n    connection.removeSignatureListener(subId);\n  }\n  done = true;\n  console.log('Returning status', status);\n  return status;\n};\n\n/* export */ const createAssociatedTokenAccountInstruction = (\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey,\n) => {\n  const keys = [\n    { pubkey: payer, isSigner: true, isWritable: true },\n    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n    { pubkey: walletAddress, isSigner: false, isWritable: false },\n    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new anchor.web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n};\n\nexport const getCandyMachineState = async (\n  anchorWallet: anchor.Wallet,\n  candyMachineId: anchor.web3.PublicKey,\n  connection: anchor.web3.Connection,\n): Promise<CandyMachine> => {\n  const provider = new anchor.Provider(connection, anchorWallet, {\n    preflightCommitment: 'recent',\n  });\n\n  const idl = await anchor.Program.fetchIdl(CANDY_MACHINE_PROGRAM, provider);\n\n  const program = new anchor.Program(idl, CANDY_MACHINE_PROGRAM, provider);\n\n  const state: any = await program.account.candyMachine.fetch(candyMachineId);\n  const itemsAvailable = state.data.itemsAvailable.toNumber();\n  const itemsRedeemed = state.itemsRedeemed.toNumber();\n  const itemsRemaining = itemsAvailable - itemsRedeemed;\n\n  return {\n    id: candyMachineId,\n    program,\n    state: {\n      itemsAvailable,\n      itemsRedeemed,\n      itemsRemaining,\n      isSoldOut: itemsRemaining === 0,\n      isActive:\n        state.data.goLiveDate &&\n        state.data.goLiveDate.toNumber() < new Date().getTime() / 1000 &&\n        (state.endSettings\n          ? state.endSettings.endSettingType.date\n            ? state.endSettings.number.toNumber() > new Date().getTime() / 1000\n            : itemsRedeemed < state.endSettings.number.toNumber()\n          : true),\n      goLiveDate: state.data.goLiveDate,\n      treasury: state.wallet,\n      tokenMint: state.tokenMint,\n      gatekeeper: state.data.gatekeeper,\n      endSettings: state.data.endSettings,\n      whitelistMintSettings: state.data.whitelistMintSettings,\n      hiddenSettings: state.data.hiddenSettings,\n      price: state.data.price,\n    },\n  };\n};\n\nconst getMasterEdition = async (\n  mint: anchor.web3.PublicKey,\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nconst getMetadata = async (\n  mint: anchor.web3.PublicKey,\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getCandyMachineCreator = async (\n  candyMachine: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [Buffer.from('candy_machine'), candyMachine.toBuffer()],\n    CANDY_MACHINE_PROGRAM,\n  );\n};\n\nexport const mintOneToken = async (\n    candyMachine: CandyMachine,\n    payer: anchor.web3.PublicKey,\n    mint: anchor.web3.Keypair\n): Promise<(string | undefined)[]> => {\n  const userTokenAccountAddress = (\n    await getAtaForMint(mint.publicKey, payer)\n  )[0];\n\n  const userPayingAccountAddress = candyMachine.state.tokenMint\n    ? (await getAtaForMint(candyMachine.state.tokenMint, payer))[0]\n    : payer;\n\n  const candyMachineAddress = candyMachine.id;\n  const remainingAccounts = [];\n  const signers: anchor.web3.Keypair[] = [mint];\n  const cleanupInstructions = [];\n  const instructions = [\n    anchor.web3.SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: mint.publicKey,\n      space: MintLayout.span,\n      lamports:\n        await candyMachine.program.provider.connection.getMinimumBalanceForRentExemption(\n          MintLayout.span,\n        ),\n      programId: TOKEN_PROGRAM_ID,\n    }),\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      0,\n      payer,\n      payer,\n    ),\n    createAssociatedTokenAccountInstruction(\n      userTokenAccountAddress,\n      payer,\n      payer,\n      mint.publicKey,\n    ),\n    Token.createMintToInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      userTokenAccountAddress,\n      payer,\n      [],\n      1,\n    ),\n  ];\n\n  if (candyMachine.state.gatekeeper) {\n    remainingAccounts.push({\n      pubkey: (\n        await getNetworkToken(\n          payer,\n          candyMachine.state.gatekeeper.gatekeeperNetwork,\n        )\n      )[0],\n      isWritable: true,\n      isSigner: false,\n    });\n    if (candyMachine.state.gatekeeper.expireOnUse) {\n      remainingAccounts.push({\n        pubkey: CIVIC,\n        isWritable: false,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: (\n          await getNetworkExpire(\n            candyMachine.state.gatekeeper.gatekeeperNetwork,\n          )\n        )[0],\n        isWritable: false,\n        isSigner: false,\n      });\n    }\n  }\n  if (candyMachine.state.whitelistMintSettings) {\n    const mint = new anchor.web3.PublicKey(\n      candyMachine.state.whitelistMintSettings.mint,\n    );\n\n    const whitelistToken = (await getAtaForMint(mint, payer))[0];\n    remainingAccounts.push({\n      pubkey: whitelistToken,\n      isWritable: true,\n      isSigner: false,\n    });\n\n    if (candyMachine.state.whitelistMintSettings.mode.burnEveryTime) {\n      const whitelistBurnAuthority = anchor.web3.Keypair.generate();\n\n      remainingAccounts.push({\n        pubkey: mint,\n        isWritable: true,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: whitelistBurnAuthority.publicKey,\n        isWritable: false,\n        isSigner: true,\n      });\n      signers.push(whitelistBurnAuthority);\n      const exists =\n        await candyMachine.program.provider.connection.getAccountInfo(\n          whitelistToken,\n        );\n      if (exists) {\n        instructions.push(\n          Token.createApproveInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            whitelistBurnAuthority.publicKey,\n            payer,\n            [],\n            1,\n          ),\n        );\n        cleanupInstructions.push(\n          Token.createRevokeInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            payer,\n            [],\n          ),\n        );\n      }\n    }\n  }\n\n  if (candyMachine.state.tokenMint) {\n    const transferAuthority = anchor.web3.Keypair.generate();\n\n    signers.push(transferAuthority);\n    remainingAccounts.push({\n      pubkey: userPayingAccountAddress,\n      isWritable: true,\n      isSigner: false,\n    });\n    remainingAccounts.push({\n      pubkey: transferAuthority.publicKey,\n      isWritable: false,\n      isSigner: true,\n    });\n\n    instructions.push(\n      Token.createApproveInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        transferAuthority.publicKey,\n        payer,\n        [],\n        candyMachine.state.price.toNumber(),\n      ),\n    );\n    cleanupInstructions.push(\n      Token.createRevokeInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        payer,\n        [],\n      ),\n    );\n  }\n  const metadataAddress = await getMetadata(mint.publicKey);\n  const masterEdition = await getMasterEdition(mint.publicKey);\n\n  const [candyMachineCreator, creatorBump] = await getCandyMachineCreator(\n    candyMachineAddress,\n  );\n\n  instructions.push(\n    await candyMachine.program.instruction.mintNft(creatorBump, {\n      accounts: {\n        candyMachine: candyMachineAddress,\n        candyMachineCreator,\n        payer: payer,\n        wallet: candyMachine.state.treasury,\n        mint: mint.publicKey,\n        metadata: metadataAddress,\n        masterEdition,\n        mintAuthority: payer,\n        updateAuthority: payer,\n        tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        systemProgram: SystemProgram.programId,\n        rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n        clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n        recentBlockhashes: anchor.web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n      },\n      remainingAccounts:\n        remainingAccounts.length > 0 ? remainingAccounts : undefined,\n    }),\n  );\n\n  try {\n    return (\n      await sendTransactions(\n        candyMachine.program.provider.connection,\n        candyMachine.program.provider.wallet,\n        [instructions, cleanupInstructions],\n        [signers, []],\n      )\n    ).txs.map(t => t.txid);\n  } catch (e) {\n    console.log(e);\n  }\n\n  return [];\n};\n\nexport const shortenAddress = (address: string, chars = 4): string => {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = (ms: number): Promise<void> => {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}","import {\n    Keypair,\n    Commitment,\n    Connection,\n    RpcResponseAndContext,\n    SignatureStatus,\n    SimulatedTransactionResponse,\n    Transaction,\n    TransactionInstruction,\n    TransactionSignature,\n    Blockhash,\n    FeeCalculator,\n  } from '@solana/web3.js';\n  \n  import { WalletNotConnectedError } from '@solana/wallet-adapter-base';\n  \n  interface BlockhashAndFeeCalculator {\n    blockhash: Blockhash;\n    feeCalculator: FeeCalculator;\n  }\n  \n  export const getErrorForTransaction = async (\n    connection: Connection,\n    txid: string,\n  ) => {\n    // wait for all confirmation before geting transaction\n    await connection.confirmTransaction(txid, 'max');\n  \n    const tx = await connection.getParsedConfirmedTransaction(txid);\n  \n    const errors: string[] = [];\n    if (tx?.meta && tx.meta.logMessages) {\n      tx.meta.logMessages.forEach(log => {\n        const regex = /Error: (.*)/gm;\n        let m;\n        while ((m = regex.exec(log)) !== null) {\n          // This is necessary to avoid infinite loops with zero-width matches\n          if (m.index === regex.lastIndex) {\n            regex.lastIndex++;\n          }\n  \n          if (m.length > 1) {\n            errors.push(m[1]);\n          }\n        }\n      });\n    }\n  \n    return errors;\n  };\n  \n  export enum SequenceType {\n    Sequential,\n    Parallel,\n    StopOnFailure,\n  }\n  \n  export async function sendTransactionsWithManualRetry(\n    connection: Connection,\n    wallet: any,\n    instructions: TransactionInstruction[][],\n    signers: Keypair[][],\n  ): Promise<(string | undefined)[]> {\n    let stopPoint = 0;\n    let tries = 0;\n    let lastInstructionsLength = null;\n    let toRemoveSigners: Record<number, boolean> = {};\n    instructions = instructions.filter((instr, i) => {\n      if (instr.length > 0) {\n        return true;\n      } else {\n        toRemoveSigners[i] = true;\n        return false;\n      }\n    });\n    let ids: string[] = [];\n    let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n  \n    while (stopPoint < instructions.length && tries < 3) {\n      instructions = instructions.slice(stopPoint, instructions.length);\n      filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n  \n      if (instructions.length === lastInstructionsLength) tries = tries + 1;\n      else tries = 0;\n  \n      try {\n        if (instructions.length === 1) {\n          const id = await sendTransactionWithRetry(\n            connection,\n            wallet,\n            instructions[0],\n            filteredSigners[0],\n            'single',\n          );\n          ids.push(id.txid);\n          stopPoint = 1;\n        } else {\n          const { txs } = await sendTransactions(\n            connection,\n            wallet,\n            instructions,\n            filteredSigners,\n            SequenceType.StopOnFailure,\n            'single',\n          );\n          ids = ids.concat(txs.map(t => t.txid));\n        }\n      } catch (e) {\n        console.error(e);\n      }\n      console.log(\n        'Died on ',\n        stopPoint,\n        'retrying from instruction',\n        instructions[stopPoint],\n        'instructions length is',\n        instructions.length,\n      );\n      lastInstructionsLength = instructions.length;\n    }\n  \n    return ids;\n  }\n  \n  export const sendTransactions = async (\n    connection: Connection,\n    wallet: any,\n    instructionSet: TransactionInstruction[][],\n    signersSet: Keypair[][],\n    sequenceType: SequenceType = SequenceType.Parallel,\n    commitment: Commitment = 'singleGossip',\n    successCallback: (txid: string, ind: number) => void = (txid, ind) => { },\n    failCallback: (reason: string, ind: number) => boolean = (txid, ind) => false,\n    block?: BlockhashAndFeeCalculator,\n  ): Promise<{ number: number; txs: { txid: string; slot: number }[] }> => {\n    if (!wallet.publicKey) throw new WalletNotConnectedError();\n  \n    const unsignedTxns: Transaction[] = [];\n  \n    if (!block) {\n      block = await connection.getRecentBlockhash(commitment);\n    }\n  \n    for (let i = 0; i < instructionSet.length; i++) {\n      const instructions = instructionSet[i];\n      const signers = signersSet[i];\n  \n      if (instructions.length === 0) {\n        continue;\n      }\n  \n      let transaction = new Transaction();\n      instructions.forEach(instruction => transaction.add(instruction));\n      transaction.recentBlockhash = block.blockhash;\n      transaction.setSigners(\n        // fee payed by the wallet owner\n        wallet.publicKey,\n        ...signers.map(s => s.publicKey),\n      );\n  \n      if (signers.length > 0) {\n        transaction.partialSign(...signers);\n      }\n  \n      unsignedTxns.push(transaction);\n    }\n  \n    const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n  \n    const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\n  \n    let breakEarlyObject = { breakEarly: false, i: 0 };\n    console.log(\n      'Signed txns length',\n      signedTxns.length,\n      'vs handed in length',\n      instructionSet.length,\n    );\n    for (let i = 0; i < signedTxns.length; i++) {\n      const signedTxnPromise = sendSignedTransaction({\n        connection,\n        signedTransaction: signedTxns[i],\n      });\n  \n      signedTxnPromise\n        .then(({ txid, slot }) => {\n          successCallback(txid, i);\n        })\n        .catch(reason => {\n          // @ts-ignore\n          failCallback(signedTxns[i], i);\n          if (sequenceType === SequenceType.StopOnFailure) {\n            breakEarlyObject.breakEarly = true;\n            breakEarlyObject.i = i;\n          }\n        });\n  \n      if (sequenceType !== SequenceType.Parallel) {\n        try {\n          await signedTxnPromise;\n        } catch (e) {\n          console.log('Caught failure', e);\n          if (breakEarlyObject.breakEarly) {\n            console.log('Died on ', breakEarlyObject.i);\n            // Return the txn we failed on by index\n            return {\n              number: breakEarlyObject.i,\n              txs: await Promise.all(pendingTxns),\n            };\n          }\n        }\n      } else {\n        pendingTxns.push(signedTxnPromise);\n      }\n    }\n  \n    if (sequenceType !== SequenceType.Parallel) {\n      await Promise.all(pendingTxns);\n    }\n  \n    return { number: signedTxns.length, txs: await Promise.all(pendingTxns) };\n  };\n  \n  export const sendTransaction = async (\n    connection: Connection,\n    wallet: any,\n    instructions: TransactionInstruction[],\n    signers: Keypair[],\n    awaitConfirmation = true,\n    commitment: Commitment = 'singleGossip',\n    includesFeePayer: boolean = false,\n    block?: BlockhashAndFeeCalculator,\n  ) => {\n    if (!wallet.publicKey) throw new WalletNotConnectedError();\n  \n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = (\n      block || (await connection.getRecentBlockhash(commitment))\n    ).blockhash;\n  \n    if (includesFeePayer) {\n      transaction.setSigners(...signers.map(s => s.publicKey));\n    } else {\n      transaction.setSigners(\n        // fee payed by the wallet owner\n        wallet.publicKey,\n        ...signers.map(s => s.publicKey),\n      );\n    }\n  \n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n    if (!includesFeePayer) {\n      transaction = await wallet.signTransaction(transaction);\n    }\n  \n    const rawTransaction = transaction.serialize();\n    let options = {\n      skipPreflight: true,\n      commitment,\n    };\n  \n    const txid = await connection.sendRawTransaction(rawTransaction, options);\n    let slot = 0;\n  \n    if (awaitConfirmation) {\n      const confirmation = await awaitTransactionSignatureConfirmation(\n        txid,\n        DEFAULT_TIMEOUT,\n        connection,\n        commitment,\n      );\n  \n      if (!confirmation)\n        throw new Error('Timed out awaiting confirmation on transaction');\n      slot = confirmation?.slot || 0;\n  \n      if (confirmation?.err) {\n        const errors = await getErrorForTransaction(connection, txid);\n  \n        console.log(errors);\n        throw new Error(`Raw transaction ${txid} failed`);\n      }\n    }\n  \n    return { txid, slot };\n  };\n  \n  export const sendTransactionWithRetry = async (\n    connection: Connection,\n    wallet: any,\n    instructions: TransactionInstruction[],\n    signers: Keypair[],\n    commitment: Commitment = 'singleGossip',\n    includesFeePayer: boolean = false,\n    block?: BlockhashAndFeeCalculator,\n    beforeSend?: () => void,\n  ) => {\n    if (!wallet.publicKey) throw new WalletNotConnectedError();\n  \n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = (\n      block || (await connection.getRecentBlockhash(commitment))\n    ).blockhash;\n  \n    if (includesFeePayer) {\n      transaction.setSigners(...signers.map(s => s.publicKey));\n    } else {\n      transaction.setSigners(\n        // fee payed by the wallet owner\n        wallet.publicKey,\n        ...signers.map(s => s.publicKey),\n      );\n    }\n  \n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n    if (!includesFeePayer) {\n      transaction = await wallet.signTransaction(transaction);\n    }\n  \n    if (beforeSend) {\n      beforeSend();\n    }\n  \n    const { txid, slot } = await sendSignedTransaction({\n      connection,\n      signedTransaction: transaction,\n    });\n  \n    return { txid, slot };\n  };\n  \n  export const getUnixTs = () => {\n    return new Date().getTime() / 1000;\n  };\n  \n  const DEFAULT_TIMEOUT = 30000;\n  \n  export async function sendSignedTransaction({\n    signedTransaction,\n    connection,\n    timeout = DEFAULT_TIMEOUT,\n  }: {\n    signedTransaction: Transaction;\n    connection: Connection;\n    sendingMessage?: string;\n    sentMessage?: string;\n    successMessage?: string;\n    timeout?: number;\n  }): Promise<{ txid: string; slot: number }> {\n    const rawTransaction = signedTransaction.serialize();\n    const startTime = getUnixTs();\n    let slot = 0;\n    const txid: TransactionSignature = await connection.sendRawTransaction(\n      rawTransaction,\n      {\n        skipPreflight: true,\n      },\n    );\n  \n    console.log('Started awaiting confirmation for', txid);\n  \n    let done = false;\n    (async () => {\n      while (!done && getUnixTs() - startTime < timeout) {\n        connection.sendRawTransaction(rawTransaction, {\n          skipPreflight: true,\n        });\n        await sleep(500);\n      }\n    })();\n    try {\n      const confirmation = await awaitTransactionSignatureConfirmation(\n        txid,\n        timeout,\n        connection,\n        'recent',\n        true,\n      );\n  \n      if (!confirmation)\n        throw new Error('Timed out awaiting confirmation on transaction');\n  \n      if (confirmation.err) {\n        console.error(confirmation.err);\n        throw new Error('Transaction failed: Custom instruction error');\n      }\n  \n      slot = confirmation?.slot || 0;\n    } catch (err: any) {\n      console.error('Timeout Error caught', err);\n      if (err.timeout) {\n        throw new Error('Timed out awaiting confirmation on transaction');\n      }\n      let simulateResult: SimulatedTransactionResponse | null = null;\n      try {\n        simulateResult = (\n          await simulateTransaction(connection, signedTransaction, 'single')\n        ).value;\n      } catch (e) { }\n      if (simulateResult && simulateResult.err) {\n        if (simulateResult.logs) {\n          for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n            const line = simulateResult.logs[i];\n            if (line.startsWith('Program log: ')) {\n              throw new Error(\n                'Transaction failed: ' + line.slice('Program log: '.length),\n              );\n            }\n          }\n        }\n        throw new Error(JSON.stringify(simulateResult.err));\n      }\n      // throw new Error('Transaction failed');\n    } finally {\n      done = true;\n    }\n  \n    console.log('Latency', txid, getUnixTs() - startTime);\n    return { txid, slot };\n  }\n  \n  async function simulateTransaction(\n    connection: Connection,\n    transaction: Transaction,\n    commitment: Commitment,\n  ): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n    // @ts-ignore\n    transaction.recentBlockhash = await connection._recentBlockhash(\n      // @ts-ignore\n      connection._disableBlockhashCaching,\n    );\n  \n    const signData = transaction.serializeMessage();\n    // @ts-ignore\n    const wireTransaction = transaction._serialize(signData);\n    const encodedTransaction = wireTransaction.toString('base64');\n    const config: any = { encoding: 'base64', commitment };\n    const args = [encodedTransaction, config];\n  \n    // @ts-ignore\n    const res = await connection._rpcRequest('simulateTransaction', args);\n    if (res.error) {\n      throw new Error('failed to simulate transaction: ' + res.error.message);\n    }\n    return res.result;\n  }\n  \n  async function awaitTransactionSignatureConfirmation(\n    txid: TransactionSignature,\n    timeout: number,\n    connection: Connection,\n    commitment: Commitment = 'recent',\n    queryStatus = false,\n  ): Promise<SignatureStatus | null | void> {\n    let done = false;\n    let status: SignatureStatus | null | void = {\n      slot: 0,\n      confirmations: 0,\n      err: null,\n    };\n    let subId = 0;\n    status = await new Promise(async (resolve, reject) => {\n      setTimeout(() => {\n        if (done) {\n          return;\n        }\n        done = true;\n        console.log('Rejecting for timeout...');\n        reject({ timeout: true });\n      }, timeout);\n      try {\n        subId = connection.onSignature(\n          txid,\n          (result, context) => {\n            done = true;\n            status = {\n              err: result.err,\n              slot: context.slot,\n              confirmations: 0,\n            };\n            if (result.err) {\n              console.log('Rejected via websocket', result.err);\n              reject(status);\n            } else {\n              console.log('Resolved via websocket', result);\n              resolve(status);\n            }\n          },\n          commitment,\n        );\n      } catch (e) {\n        done = true;\n        console.error('WS error in setup', txid, e);\n      }\n      while (!done && queryStatus) {\n        // eslint-disable-next-line no-loop-func\n        (async () => {\n          try {\n            const signatureStatuses = await connection.getSignatureStatuses([\n              txid,\n            ]);\n            status = signatureStatuses && signatureStatuses.value[0];\n            if (!done) {\n              if (!status) {\n                console.log('REST null result for', txid, status);\n              } else if (status.err) {\n                console.log('REST error for', txid, status);\n                done = true;\n                reject(status.err);\n              } else if (!status.confirmations) {\n                console.log('REST no confirmations for', txid, status);\n              } else {\n                console.log('REST confirmation for', txid, status);\n                done = true;\n                resolve(status);\n              }\n            }\n          } catch (e) {\n            if (!done) {\n              console.log('REST connection error: txid', txid, e);\n            }\n          }\n        })();\n        await sleep(2000);\n      }\n    });\n  \n    //@ts-ignore\n    if (connection._signatureSubscriptions[subId])\n      connection.removeSignatureListener(subId);\n    done = true;\n    console.log('Returning status', status);\n    return status;\n  }\n  export function sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  ","import styled from 'styled-components';\nimport {useEffect, useState} from 'react';\nimport Button from '@material-ui/core/Button';\nimport {CircularProgress} from '@material-ui/core';\nimport {GatewayStatus, useGateway} from '@civic/solana-gateway-react';\nimport {CandyMachine} from './candy-machine';\n\n\nexport const CTAButton = styled(Button)`\n  display: block !important;\n  margin: 0 auto !important;\n  background-color: var(--title-text-color) !important;\n  min-width: 120px !important;\n  font-size: 1em !important;\n`;\n\nexport const MintButton = ({\n                               onMint,\n                               candyMachine,\n                               isMinting,\n                               isEnded,\n                               isActive,\n                               isSoldOut\n                           }: {\n    onMint: () => Promise<void>;\n    candyMachine: CandyMachine | undefined;\n    isMinting: boolean;\n    isEnded: boolean;\n    isActive: boolean;\n    isSoldOut: boolean;\n}) => {\n    const {requestGatewayToken, gatewayStatus} = useGateway();\n    const [clicked, setClicked] = useState(false);\n    const [isVerifying, setIsVerifying] = useState(false);\n\n    useEffect(() => {\n        setIsVerifying(false);\n        if (gatewayStatus === GatewayStatus.COLLECTING_USER_INFORMATION && clicked) {\n            // when user approves wallet verification txn\n            setIsVerifying(true);\n        } else if (gatewayStatus === GatewayStatus.ACTIVE && clicked) {\n            console.log('Verified human, now minting...');\n            onMint();\n            setClicked(false);\n        }\n    }, [gatewayStatus, clicked, setClicked, onMint]);\n\n    return (\n        <CTAButton\n            disabled={\n                clicked ||\n                candyMachine?.state.isSoldOut ||\n                isSoldOut ||\n                isMinting ||\n                isEnded ||\n                !isActive ||\n                isVerifying\n            }\n            onClick={async () => {\n                if (isActive && candyMachine?.state.gatekeeper && gatewayStatus !== GatewayStatus.ACTIVE) {\n                    console.log('Requesting gateway token');\n                    setClicked(true);\n                    await requestGatewayToken();\n                } else {\n                    console.log('Minting...');\n                    await onMint();\n                }\n            }}\n            variant=\"contained\"\n        >\n            {!candyMachine ? (\n                \"CONNECTING...\"\n            ) : candyMachine?.state.isSoldOut || isSoldOut ? (\n                'SOLD OUT'\n            ) : isActive ? (\n                isVerifying ? 'VERIFYING...' :\n                    isMinting || clicked ? (\n                        <CircularProgress/>\n                    ) : (\n                        \"MINT\"\n                    )\n            ) : isEnded ? \"ENDED\" : (candyMachine?.state.goLiveDate ? (\n                \"SOON\"\n            ) : (\n                \"UNAVAILABLE\"\n            ))}\n        </CTAButton>\n    );\n};\n","import {useEffect, useState} from \"react\";\nimport styled from \"styled-components\";\nimport confetti from \"canvas-confetti\";\nimport * as anchor from \"@project-serum/anchor\";\nimport {LAMPORTS_PER_SOL, PublicKey} from \"@solana/web3.js\";\nimport {useAnchorWallet} from \"@solana/wallet-adapter-react\";\nimport {WalletMultiButton} from \"@solana/wallet-adapter-react-ui\";\nimport {GatewayProvider} from '@civic/solana-gateway-react';\nimport Countdown from \"react-countdown\";\nimport {Snackbar, Paper, LinearProgress, Chip} from \"@material-ui/core\";\nimport Alert from \"@material-ui/lab/Alert\";\nimport {toDate, AlertState, getAtaForMint} from './utils';\nimport {MintButton} from './MintButton';\nimport {\n    CandyMachine,\n    awaitTransactionSignatureConfirmation,\n    getCandyMachineState,\n    mintOneToken,\n    CANDY_MACHINE_PROGRAM,\n} from \"./candy-machine\";\n\nconst cluster = process.env.REACT_APP_SOLANA_NETWORK!.toString();\nconst decimals = process.env.REACT_APP_SPL_TOKEN_TO_MINT_DECIMALS ? +process.env.REACT_APP_SPL_TOKEN_TO_MINT_DECIMALS!.toString() : 9;\nconst splTokenName = process.env.REACT_APP_SPL_TOKEN_TO_MINT_NAME ? process.env.REACT_APP_SPL_TOKEN_TO_MINT_NAME.toString() : \"TOKEN\";\n\nconst WalletContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  justify-content: center;\n`;\n\nconst WalletAmount = styled.div`\n  color: black;\n  width: auto;\n  padding: 5px 5px 5px 16px;\n  min-width: 48px;\n  min-height: auto;\n  border-radius: 22px;\n  background-color: var(--main-text-color);\n  box-shadow: 0px 3px 5px -1px rgb(0 0 0 / 20%), 0px 6px 10px 0px rgb(0 0 0 / 14%), 0px 1px 18px 0px rgb(0 0 0 / 12%);\n  box-sizing: border-box;\n  transition: background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms, box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms, border 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;\n  font-weight: 500;\n  line-height: 1.75;\n  text-transform: uppercase;\n  border: 0;\n  margin: 0;\n  display: inline-flex;\n  outline: 0;\n  position: relative;\n  align-items: center;\n  user-select: none;\n  vertical-align: middle;\n  justify-content: flex-start;\n  gap: 10px;\n`;\n\nconst Wallet = styled.ul`\n  flex: 0 0 auto;\n  margin: 0;\n  padding: 0;\n`;\n\nconst ConnectButton = styled(WalletMultiButton)`\n  border-radius: 18px !important;\n  padding: 6px 16px;\n  background-color: #4E44CE;\n  margin: 0 auto;\n`;\n\nconst NFT = styled(Paper)`\n  min-width: 500px;\n  padding: 5px 20px 20px 20px;\n  flex: 1 1 auto;\n  background-color: var(--card-background-color) !important;\n  box-shadow: 0 14px 28px rgba(0,0,0,0.25), 0 10px 10px rgba(0,0,0,0.22) !important;\n`;\n\nconst Des = styled(NFT)`\n  text-align: left;\n  padding-top: 0px;\n`;\n\n\nconst Card = styled(Paper)`\n  display: inline-block;\n  background-color: var(card-background-lighter-color) !important;\n  margin: 5px;\n  min-width: 40px;\n  padding: 24px;\n  h1{\n    margin:0px;\n  }\n`;\n\nconst MintButtonContainer = styled.div`\n  button.MuiButton-contained:not(.MuiButton-containedPrimary).Mui-disabled {\n    color: #464646;\n  }\n\n  button.MuiButton-contained:not(.MuiButton-containedPrimary):hover,\n  button.MuiButton-contained:not(.MuiButton-containedPrimary):focus {\n    -webkit-animation: pulse 1s;\n    animation: pulse 1s;\n    box-shadow: 0 0 0 2em rgba(255, 255, 255, 0);\n  }\n\n  @-webkit-keyframes pulse {\n    0% {\n      box-shadow: 0 0 0 0 #ef8f6e;\n    }\n  }\n\n  @keyframes pulse {\n    0% {\n      box-shadow: 0 0 0 0 #ef8f6e;\n    }\n  }\n`;\n\nconst Logo = styled.div`\n  flex: 0 0 auto;\n\n  img {\n    height: 60px;\n  }\n`;\nconst Menu = styled.ul`\n  list-style: none;\n  display: inline-flex;\n  flex: 1 0 auto;\n\n  li {\n    margin: 0 12px;\n\n    a {\n      color: var(--main-text-color);\n      list-style-image: none;\n      list-style-position: outside;\n      list-style-type: none;\n      outline: none;\n      text-decoration: none;\n      text-size-adjust: 100%;\n      touch-action: manipulation;\n      transition: color 0.3s;\n      padding-bottom: 15px;\n\n      img {\n        max-height: 26px;\n      }\n    }\n\n    a:hover, a:active {\n      color: rgb(131, 146, 161);\n      border-bottom: 4px solid var(--title-text-color);\n    }\n\n  }\n`;\n\nconst SolExplorerLink = styled.a`\n  color: var(--title-text-color);\n  border-bottom: 1px solid var(--title-text-color);\n  font-weight: bold;\n  list-style-image: none;\n  list-style-position: outside;\n  list-style-type: none;\n  outline: none;\n  text-decoration: none;\n  text-size-adjust: 100%;\n\n  :hover {\n    border-bottom: 2px solid var(--title-text-color);\n  }\n`;\n\nconst MainContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  margin-top: 20px;\n  margin-bottom: 20px;\n  margin-right: 4%;\n  margin-left: 4%;\n  text-align: center;\n  justify-content: center;\n`;\n\nconst MintContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  flex: 1 1 auto;\n  flex-wrap: wrap;\n  gap: 20px;\n`;\n\nconst DesContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  flex: 1 1 auto;\n  gap: 20px;\n`;\n\nconst Price = styled(Chip)`\n  position: absolute;\n  margin: 5px;\n  font-weight: bold;\n  font-size: 1.2em !important;\n  font-family: 'Patrick Hand', cursive !important;\n`;\n\nconst Image = styled.img`\n  height: 400px;\n  width: auto;\n  border-radius: 7px;\n  box-shadow: 5px 5px 40px 5px rgba(0,0,0,0.5);\n`;\n\nconst BorderLinearProgress = styled(LinearProgress)`\n  margin: 20px;\n  height: 10px !important;\n  border-radius: 30px;\n  border: 2px solid white;\n  box-shadow: 5px 5px 40px 5px rgba(0,0,0,0.5);\n  background-color:var(--main-text-color) !important;\n  \n  > div.MuiLinearProgress-barColorPrimary{\n    background-color:var(--title-text-color) !important;\n  }\n\n  > div.MuiLinearProgress-bar1Determinate {\n    border-radius: 30px !important;\n    background-image: linear-gradient(270deg, rgba(255, 255, 255, 0.01), rgba(255, 255, 255, 0.5));\n  }\n`;\n\nconst ShimmerTitle = styled.h1`\n  margin: 20px auto;\n  text-transform: uppercase;\n  animation: glow 2s ease-in-out infinite alternate;\n  color: var(--main-text-color);\n  @keyframes glow {\n    from {\n      text-shadow: 0 0 20px var(--main-text-color);\n    }\n    to {\n      text-shadow: 0 0 30px var(--title-text-color), 0 0 10px var(--title-text-color);\n    }\n  }\n`;\n\nconst GoldTitle = styled.h2`\n  color: var(--title-text-color);\n`;\n\nconst LogoAligner = styled.div`\n  display: flex;\n  align-items: center;\n\n  img {\n    max-height: 35px;\n    margin-right: 10px;\n  }\n`;\n\n\nexport interface HomeProps {\n    candyMachineId: anchor.web3.PublicKey;\n    connection: anchor.web3.Connection;\n    txTimeout: number;\n    rpcHost: string;\n}\n\nconst Home = (props: HomeProps) => {\n    const [balance, setBalance] = useState<number>();\n    const [isMinting, setIsMinting] = useState(false); // true when user got to press MINT\n    const [isActive, setIsActive] = useState(false); // true when countdown completes or whitelisted\n    const [solanaExplorerLink, setSolanaExplorerLink] = useState<string>(\"\");\n    const [itemsAvailable, setItemsAvailable] = useState(0);\n    const [itemsRedeemed, setItemsRedeemed] = useState(0);\n    const [itemsRemaining, setItemsRemaining] = useState(0);\n    const [isSoldOut, setIsSoldOut] = useState(false);\n    const [payWithSplToken, setPayWithSplToken] = useState(false);\n    const [price, setPrice] = useState(0);\n    const [priceLabel, setPriceLabel] = useState<string>(\"SOL\");\n    const [whitelistPrice, setWhitelistPrice] = useState(0);\n    const [whitelistEnabled, setWhitelistEnabled] = useState(false);\n    const [isBurnToken, setIsBurnToken] = useState(false);\n    const [whitelistTokenBalance, setWhitelistTokenBalance] = useState(0);\n    const [isEnded, setIsEnded] = useState(false);\n    const [endDate, setEndDate] = useState<Date>();\n    const [isPresale, setIsPresale] = useState(false);\n    const [isWLOnly, setIsWLOnly] = useState(false);\n\n    const [alertState, setAlertState] = useState<AlertState>({\n        open: false,\n        message: \"\",\n        severity: undefined,\n    });\n\n    const wallet = useAnchorWallet();\n    const [candyMachine, setCandyMachine] = useState<CandyMachine>();\n\n    const rpcUrl = props.rpcHost;\n\n    const refreshCandyMachineState = () => {\n        (async () => {\n            if (!wallet) return;\n\n            const cndy = await getCandyMachineState(\n                wallet as anchor.Wallet,\n                props.candyMachineId,\n                props.connection\n            );\n\n            setCandyMachine(cndy);\n            setItemsAvailable(cndy.state.itemsAvailable);\n            setItemsRemaining(cndy.state.itemsRemaining);\n            setItemsRedeemed(cndy.state.itemsRedeemed);\n\n            var divider = 1;\n            if (decimals) {\n                divider = +('1' + new Array(decimals).join('0').slice() + '0');\n            }\n\n            // detect if using spl-token to mint\n            if (cndy.state.tokenMint) {\n                setPayWithSplToken(true);\n                // Customize your SPL-TOKEN Label HERE\n                // TODO: get spl-token metadata name\n                setPriceLabel(splTokenName);\n                setPrice(cndy.state.price.toNumber() / divider);\n                setWhitelistPrice(cndy.state.price.toNumber() / divider);\n            }else {\n                setPrice(cndy.state.price.toNumber() / LAMPORTS_PER_SOL);\n                setWhitelistPrice(cndy.state.price.toNumber() / LAMPORTS_PER_SOL);\n            }\n\n\n            // fetch whitelist token balance\n            if (cndy.state.whitelistMintSettings) {\n                setWhitelistEnabled(true);\n                setIsBurnToken(cndy.state.whitelistMintSettings.mode.burnEveryTime);\n                setIsPresale(cndy.state.whitelistMintSettings.presale);\n                setIsWLOnly(!isPresale && cndy.state.whitelistMintSettings.discountPrice === null);\n\n                if (cndy.state.whitelistMintSettings.discountPrice !== null && cndy.state.whitelistMintSettings.discountPrice !== cndy.state.price) {\n                    if (cndy.state.tokenMint) {\n                        setWhitelistPrice(cndy.state.whitelistMintSettings.discountPrice?.toNumber() / divider);\n                    } else {\n                        setWhitelistPrice(cndy.state.whitelistMintSettings.discountPrice?.toNumber() / LAMPORTS_PER_SOL);\n                    }\n                }\n\n                let balance = 0;\n                try {\n                    const tokenBalance =\n                        await props.connection.getTokenAccountBalance(\n                            (\n                                await getAtaForMint(\n                                    cndy.state.whitelistMintSettings.mint,\n                                    wallet.publicKey,\n                                )\n                            )[0],\n                        );\n\n                    balance = tokenBalance?.value?.uiAmount || 0;\n                } catch (e) {\n                    console.error(e);\n                    balance = 0;\n                }\n                setWhitelistTokenBalance(balance);\n                setIsActive(isPresale && !isEnded && balance > 0);\n            } else {\n                setWhitelistEnabled(false);\n            }\n\n            // end the mint when date is reached\n            if (cndy?.state.endSettings?.endSettingType.date) {\n                setEndDate(toDate(cndy.state.endSettings.number));\n                if (\n                    cndy.state.endSettings.number.toNumber() <\n                    new Date().getTime() / 1000\n                ) {\n                    setIsEnded(true);\n                    setIsActive(false);\n                }\n            }\n            // end the mint when amount is reached\n            if (cndy?.state.endSettings?.endSettingType.amount) {\n                let limit = Math.min(\n                    cndy.state.endSettings.number.toNumber(),\n                    cndy.state.itemsAvailable,\n                );\n                setItemsAvailable(limit);\n                if (cndy.state.itemsRedeemed < limit) {\n                    setItemsRemaining(limit - cndy.state.itemsRedeemed);\n                } else {\n                    setItemsRemaining(0);\n                    cndy.state.isSoldOut = true;\n                    setIsEnded(true);\n                }\n            } else {\n                setItemsRemaining(cndy.state.itemsRemaining);\n            }\n\n            if (cndy.state.isSoldOut) {\n                setIsActive(false);\n            }\n        })();\n    };\n\n    const renderGoLiveDateCounter = ({days, hours, minutes, seconds}: any) => {\n        return (\n            <div><Card elevation={1}><h1>{days}</h1>Days</Card><Card elevation={1}><h1>{hours}</h1>\n                Hours</Card><Card elevation={1}><h1>{minutes}</h1>Mins</Card><Card elevation={1}>\n                <h1>{seconds}</h1>Secs</Card></div>\n        );\n    };\n\n    const renderEndDateCounter = ({days, hours, minutes}: any) => {\n        let label = \"\";\n        if (days > 0) {\n            label += days + \" days \"\n        }\n        if (hours > 0) {\n            label += hours + \" hours \"\n        }\n        label += (minutes+1) + \" minutes left to MINT.\"\n        return (\n            <div><h3>{label}</h3></div>\n        );\n    };\n\n    function displaySuccess(mintPublicKey: any): void {\n        let remaining = itemsRemaining - 1;\n        setItemsRemaining(remaining);\n        setIsSoldOut(remaining === 0);\n        if (isBurnToken && whitelistTokenBalance && whitelistTokenBalance > 0) {\n            let balance = whitelistTokenBalance - 1;\n            setWhitelistTokenBalance(balance);\n            setIsActive(isPresale && !isEnded && balance > 0);\n        }\n        setItemsRedeemed(itemsRedeemed + 1);\n        const solFeesEstimation = 0.012; // approx\n        if (!payWithSplToken && balance && balance > 0) {\n            setBalance(balance - (whitelistEnabled ? whitelistPrice : price) - solFeesEstimation);\n        }\n        setSolanaExplorerLink(cluster === \"devnet\" || cluster === \"testnet\"\n            ? (\"https://solscan.io/token/\" + mintPublicKey + \"?cluster=\" + cluster)\n            : (\"https://solscan.io/token/\" + mintPublicKey));\n        throwConfetti();\n    };\n\n    function throwConfetti(): void {\n        confetti({\n            particleCount: 400,\n            spread: 70,\n            origin: {y: 0.6},\n        });\n    }\n\n    const onMint = async () => {\n        try {\n            setIsMinting(true);\n            if (wallet && candyMachine?.program && wallet.publicKey) {\n                const mint = anchor.web3.Keypair.generate();\n                const mintTxId = (\n                    await mintOneToken(candyMachine, wallet.publicKey, mint)\n                )[0];\n\n                let status: any = {err: true};\n                if (mintTxId) {\n                    status = await awaitTransactionSignatureConfirmation(\n                        mintTxId,\n                        props.txTimeout,\n                        props.connection,\n                        'singleGossip',\n                        true,\n                    );\n                }\n\n                if (!status?.err) {\n                    setAlertState({\n                        open: true,\n                        message: 'Congratulations! Mint succeeded!',\n                        severity: 'success',\n                    });\n\n                    // update front-end amounts\n                    displaySuccess(mint.publicKey);\n                } else {\n                    setAlertState({\n                        open: true,\n                        message: 'Mint failed! Please try again!',\n                        severity: 'error',\n                    });\n                }\n            }\n        } catch (error: any) {\n            // TODO: blech:\n            let message = error.msg || 'Minting failed! Please try again!';\n            if (!error.msg) {\n                if (!error.message) {\n                    message = 'Transaction Timeout! Please try again.';\n                } else if (error.message.indexOf('0x138')) {\n                } else if (error.message.indexOf('0x137')) {\n                    message = `SOLD OUT!`;\n                } else if (error.message.indexOf('0x135')) {\n                    message = `Insufficient funds to mint. Please fund your wallet.`;\n                }\n            } else {\n                if (error.code === 311) {\n                    message = `SOLD OUT!`;\n                } else if (error.code === 312) {\n                    message = `Minting period hasn't started yet.`;\n                }\n            }\n\n            setAlertState({\n                open: true,\n                message,\n                severity: \"error\",\n            });\n        } finally {\n            setIsMinting(false);\n        }\n    };\n\n\n    useEffect(() => {\n        (async () => {\n            if (wallet) {\n                const balance = await props.connection.getBalance(wallet.publicKey);\n                setBalance(balance / LAMPORTS_PER_SOL);\n            }\n        })();\n    }, [wallet, props.connection]);\n\n    useEffect(refreshCandyMachineState, [\n        wallet,\n        props.candyMachineId,\n        props.connection,\n        isEnded,\n        isPresale\n    ]);\n\n    return (\n        <main>\n             <MainContainer>\n                <WalletContainer>\n                    <Logo><a href=\"http://localhost:3000/\" target=\"_blank\" rel=\"noopener noreferrer\"><img alt=\"\"\n                                                                                                          src=\"logo sg.png\"/></a></Logo>\n                    <Menu>\n                        <li><a href=\"https://discord.gg/zd2jkYjb \" target=\"_blank\" rel=\"noopener noreferrer\"> Discord</a>\n                        </li>\n                        <li><a href=\" https://twitter.com/squareguysNFT?s=20&t=tpKG6RNJWqj21a75uAzUkw \" target=\"_blank\" rel=\"noopener noreferrer\"> Twitter</a>\n                        </li>\n                        \n                    </Menu>\n                    <Wallet>\n                        {wallet ?\n                            <WalletAmount>{(balance || 0).toLocaleString()} SOL<ConnectButton/></WalletAmount> :\n                            <ConnectButton>Connect Wallet</ConnectButton>}\n                    </Wallet>\n                </WalletContainer>\n                <ShimmerTitle>SQUARE GUYS!</ShimmerTitle>\n                <br/>\n                <MintContainer>\n                    <DesContainer>\n                        <NFT elevation={3}>\n                            <h2>LEGENDARY GUYS</h2>\n                            <br/>\n                            <div><Price\n                                label={isActive && whitelistEnabled && (whitelistTokenBalance > 0) ? (whitelistPrice + \" \" + priceLabel) : (`${price} ${priceLabel}`)}/><Image\n                                src=\"sg gif.gif\"\n                                alt=\"NFT To Mint\"/></div>\n                            <br/>\n                            {wallet && isActive && whitelistEnabled && (whitelistTokenBalance > 0) && isBurnToken &&\n                              <h3>You own {whitelistTokenBalance} WL mint {whitelistTokenBalance > 1 ? \"tokens\" : \"token\" }.</h3>}\n                            {wallet && isActive && whitelistEnabled && (whitelistTokenBalance > 0) && !isBurnToken &&\n                              <h3>You are whitelisted and allowed to mint.</h3>}\n\n                            {wallet && isActive && endDate && Date.now() < endDate.getTime() &&\n                              <Countdown\n                                date={toDate(candyMachine?.state?.endSettings?.number)}\n                                onMount={({completed}) => completed && setIsEnded(true)}\n                                onComplete={() => {\n                                    setIsEnded(true);\n                                }}\n                                renderer={renderEndDateCounter}\n                              />}\n                            {wallet && isActive &&\n                              <h3>TOTAL MINTED : {itemsRedeemed} / {itemsAvailable}</h3>}\n                            {wallet && isActive && <BorderLinearProgress variant=\"determinate\"\n                                                                         value={100 - (itemsRemaining * 100 / itemsAvailable)}/>}\n                            <br/>\n                            <MintButtonContainer>\n                                {!isActive && !isEnded && candyMachine?.state.goLiveDate && (!isWLOnly || whitelistTokenBalance > 0) ? (\n                                    <Countdown\n                                        date={toDate(candyMachine?.state.goLiveDate)}\n                                        onMount={({completed}) => completed && setIsActive(!isEnded)}\n                                        onComplete={() => {\n                                            setIsActive(!isEnded);\n                                        }}\n                                        renderer={renderGoLiveDateCounter}\n                                    />) : (\n                                    !wallet ? (\n                                            <ConnectButton>Connect Wallet</ConnectButton>\n                                        ) : (!isWLOnly || whitelistTokenBalance > 0) ?\n                                        candyMachine?.state.gatekeeper &&\n                                        wallet.publicKey &&\n                                        wallet.signTransaction ? (\n                                            <GatewayProvider\n                                                wallet={{\n                                                    publicKey:\n                                                        wallet.publicKey ||\n                                                        new PublicKey(CANDY_MACHINE_PROGRAM),\n                                                    //@ts-ignore\n                                                    signTransaction: wallet.signTransaction,\n                                                }}\n                                                // // Replace with following when added\n                                                // gatekeeperNetwork={candyMachine.state.gatekeeper_network}\n                                                gatekeeperNetwork={\n                                                    candyMachine?.state?.gatekeeper?.gatekeeperNetwork\n                                                } // This is the ignite (captcha) network\n                                                /// Don't need this for mainnet\n                                                clusterUrl={rpcUrl}\n                                                options={{autoShowModal: false}}\n                                            >\n                                                <MintButton\n                                                    candyMachine={candyMachine}\n                                                    isMinting={isMinting}\n                                                    isActive={isActive}\n                                                    isEnded={isEnded}\n                                                    isSoldOut={isSoldOut}\n                                                    onMint={onMint}\n                                                />\n                                            </GatewayProvider>\n                                        ) : (\n                                            <MintButton\n                                                candyMachine={candyMachine}\n                                                isMinting={isMinting}\n                                                isActive={isActive}\n                                                isEnded={isEnded}\n                                                isSoldOut={isSoldOut}\n                                                onMint={onMint}\n                                            />\n                                        ) :\n                                        <h1>Mint is private.</h1>\n                                        )}\n                            </MintButtonContainer>\n                            <br/>\n                            {wallet && isActive && solanaExplorerLink &&\n                              <SolExplorerLink href={solanaExplorerLink} target=\"_blank\">View on Solscan</SolExplorerLink>}\n                        </NFT>\n                    </DesContainer>\n                    <DesContainer>\n                        <Des elevation={2}>\n                        <LogoAligner><img src=\"logo sg.png\" alt=\"\"></img><GoldTitle>History of Square Guys</GoldTitle></LogoAligner>\n\n                            <p>Imagine a project where customers decide everything.\nThis is a unique project!Our team was regular\nNFT buyers.We spent all day looking for the \nperfect project to buy, but never found it. Our team couldn't \nfind an analogy to our project. We figured out what to do!\nWe need to create a project that is 100% community driven \n(by voting in our discord) You can own our collection! By buying our NFT\nyou are buying the right to vote! </p>\n                            <p>Let's say the community \nis interested in something. The task of our team is to vote\nand fulfill the wishes of our holders. You decide everything! \nThis way, the owners can decide what the future of the project\nwill be! We are your employees, and you decide what to do.\nThat's not all, the owners will have their own Collection!\nChoose everything! Also, the profits from your collection will go to your wallet!</p>\n                            <p>Friendly and cohesive team always succeeds!!</p>\n                        \n                        </Des>\n                    </DesContainer>\n                </MintContainer>\n            </MainContainer>\n            <Snackbar\n                open={alertState.open}\n                autoHideDuration={6000}\n                onClose={() => setAlertState({...alertState, open: false})}\n            >\n                <Alert\n                    onClose={() => setAlertState({...alertState, open: false})}\n                    severity={alertState.severity}\n                >\n                    {alertState.message}\n                </Alert>\n            </Snackbar>\n        </main>\n    );\n};\n\nexport default Home;\n","import { createTheme, ThemeProvider } from \"@material-ui/core\";\nimport { useMemo } from \"react\";\nimport {\n    ConnectionProvider,\n    WalletProvider,\n} from \"@solana/wallet-adapter-react\";\nimport * as anchor from \"@project-serum/anchor\";\nimport { clusterApiUrl } from \"@solana/web3.js\";\nimport { WalletAdapterNetwork } from \"@solana/wallet-adapter-base\";\nimport {\n    getPhantomWallet,\n    getSlopeWallet,\n    getSolflareWallet,\n    getSolflareWebWallet,\n    getSolletWallet,\n    getSolletExtensionWallet,\n    getSolongWallet,\n    getLedgerWallet,\n    getSafePalWallet,\n} from \"@solana/wallet-adapter-wallets\";\n\nimport {\n    WalletModalProvider\n} from '@solana/wallet-adapter-react-ui';\n\nimport \"./App.css\";\nimport Home from \"./Home\";\n\nrequire('@solana/wallet-adapter-react-ui/styles.css');\n\n\nconst candyMachineId = new anchor.web3.PublicKey(\n  process.env.REACT_APP_CANDY_MACHINE_ID!\n);\n\nconst network = process.env.REACT_APP_SOLANA_NETWORK as WalletAdapterNetwork;\n\nconst rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST!;\nconst connection = new anchor.web3.Connection(rpcHost);\n\nconst txTimeout = 30000; // milliseconds (confirm this works for your project)\n\nconst theme = createTheme({\n    palette: {\n        type: 'dark',\n    },\n    overrides: {\n        MuiButtonBase: {\n            root: {\n                justifyContent: 'flex-start',\n            },\n        },\n        MuiButton: {\n            root: {\n                textTransform: undefined,\n                padding: '12px 16px',\n            },\n            startIcon: {\n                marginRight: 8,\n            },\n            endIcon: {\n                marginLeft: 8,\n            },\n        },\n    },\n});\n\nconst App = () => {\n    // Custom RPC endpoint.\n  const endpoint = useMemo(() => clusterApiUrl(network), []);\n\n    // @solana/wallet-adapter-wallets includes all the adapters but supports tree shaking and lazy loading --\n    // Only the wallets you configure here will be compiled into your application, and only the dependencies\n    // of wallets that your users connect to will be loaded.\n    const wallets = useMemo(\n        () => [\n            getPhantomWallet(),\n            getSlopeWallet(),\n            getSolflareWallet(),\n            getSolflareWebWallet(),\n            getSolletWallet({ network }),\n            getSolletExtensionWallet({ network }),\n            getSolongWallet(),\n            getLedgerWallet(),\n            getSafePalWallet(),\n        ],\n        []\n    );\n\n  return (\n      <ThemeProvider theme={theme}>\n        <ConnectionProvider endpoint={endpoint}>\n          <WalletProvider wallets={wallets} autoConnect={true}>\n            <WalletModalProvider>\n              <Home\n                candyMachineId={candyMachineId}\n                connection={connection}\n                txTimeout={txTimeout}\n                rpcHost={rpcHost}\n              />\n            </WalletModalProvider>\n          </WalletProvider>\n        </ConnectionProvider>\n      </ThemeProvider>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import * as anchor from '@project-serum/anchor';\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { SystemProgram } from '@solana/web3.js';\nimport {\n  LAMPORTS_PER_SOL,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n} from '@solana/web3.js';\n\nexport interface AlertState {\n  open: boolean;\n  message: string;\n  severity: 'success' | 'info' | 'warning' | 'error' | undefined;\n}\n\nexport const toDate = (value?: anchor.BN) => {\n  if (!value) {\n    return;\n  }\n\n  return new Date(value.toNumber() * 1000);\n};\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n  format: (val?: number) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n  asNumber: (val?: anchor.BN) => {\n    if (!val) {\n      return undefined;\n    }\n\n    return val.toNumber() / LAMPORTS_PER_SOL;\n  },\n};\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID =\n  new anchor.web3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\nexport const CIVIC = new anchor.web3.PublicKey(\n  'gatem74V238djXdzWnJf94Wo1DcnuGkfijbf3AuBhfs',\n);\n\nexport const getAtaForMint = async (\n  mint: anchor.web3.PublicKey,\n  buyer: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [buyer.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  );\n};\n\nexport const getNetworkExpire = async (\n  gatekeeperNetwork: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [gatekeeperNetwork.toBuffer(), Buffer.from('expire')],\n    CIVIC,\n  );\n};\n\nexport const getNetworkToken = async (\n  wallet: anchor.web3.PublicKey,\n  gatekeeperNetwork: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [\n      wallet.toBuffer(),\n      Buffer.from('gateway'),\n      Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),\n      gatekeeperNetwork.toBuffer(),\n    ],\n    CIVIC,\n  );\n};\n\nexport function createAssociatedTokenAccountInstruction(\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey,\n) {\n  const keys = [\n    {\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true,\n    },\n    {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: walletAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: splTokenMintAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n}\n"],"sourceRoot":""}